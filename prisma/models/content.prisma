enum HardwarePlatform {
    Windows @map("windows")
    Linux   @map("linux")
    macOS   @map("macos")
    // Switch @map("switch")
    // etc

    //  @@map("Platform")
}

model UserPlatform {
    id String @id @default(uuid())

    platformName   String
    iconSvg        String
    fileExtensions String[] @default([])

    redistId String @unique
    redist   Redist @relation(fields: [redistId], references: [id], onDelete: Cascade, onUpdate: Cascade)

    //platform PlatformLink[]
}

model PlatformLink {
    id String @id // This is either the ID of the user platform, or a repeat of the HardwarePlatform enum. It's cursed.

    hardwarePlatform HardwarePlatform?
    // Waiting on weak reference
    // userPlatform     UserPlatform?     @relation(fields: [id], references: [id])

    gameVersions   GameVersion[]
    dlcVersions    DLCVersion[]
    redistVerisons RedistVersion[]
    modVersions    ModVersion[]
}

/**
 */
model LaunchOption {
    launchId String @id @default(uuid())

    redistVersionId String?
    redistVersion   RedistVersion? @relation(fields: [redistVersionId], references: [versionId], onDelete: Cascade, onUpdate: Cascade, map: "redistVersion_fkey")

    launchGId         String?
    launchGVersion    GameVersion? @relation(name: "launches", fields: [launchGId], references: [versionId])
    installGId        String?      @unique
    installGVersion   GameVersion? @relation(name: "install")
    uninstallGId      String?      @unique
    uninstallGVersion GameVersion? @relation(name: "uninstall")

    name        String
    description String

    command String
    args    String @default("")
}

// Platform agnostic object
model Version {
    versionId String @id @unique @default(uuid())

    versionPath String

    versionName String
    created     DateTime @default(now())

    gameId       String?
    game         Game?         @relation(fields: [gameId], references: [id], map: "game_link", onDelete: Cascade, onUpdate: Cascade)
    gameVersions GameVersion[]

    redistId       String?
    redist         Redist?         @relation(fields: [redistId], references: [id], map: "redist_link", onDelete: Cascade, onUpdate: Cascade)
    redistVersions RedistVersion[]

    dlcId       String?
    dlc         DLC?         @relation(fields: [dlcId], references: [id], map: "dlc_link", onDelete: Cascade, onUpdate: Cascade)
    dlcVersions DLCVersion[]

    modId       String?
    mod         Mod?         @relation(fields: [modId], references: [id], map: "mod_link", onDelete: Cascade, onUpdate: Cascade)
    modVersions ModVersion[]

    dropletManifest Json // Results from droplet
}

// Platform specific object
model GameVersion {
    versionId String  @id
    version   Version @relation(fields: [versionId], references: [versionId], onDelete: Cascade, onUpdate: Cascade)

    redistDeps RedistVersion[]

    launches LaunchOption[] @relation(name: "launches")

    installId   String?       @unique
    install     LaunchOption? @relation(name: "install", fields: [installId], references: [launchId])
    uninstallId String?       @unique
    uninstall   LaunchOption? @relation(name: "uninstall", fields: [uninstallId], references: [launchId])
    onlySetup   Boolean       @default(false)

    umuIdOverride String?

    versionIndex Int
    delta        Boolean @default(false)
    hidden       Boolean @default(false)

    platformId String
    platform   PlatformLink @relation(fields: [platformId], references: [id])
}

// Platform specific object
model DLCVersion {
    versionId String  @id
    version   Version @relation(fields: [versionId], references: [versionId], onDelete: Cascade, onUpdate: Cascade)

    redistDeps RedistVersion[]

    platformId String
    platform   PlatformLink @relation(fields: [platformId], references: [id])
}

// Platform specific object
model RedistVersion {
    versionId String  @id
    version   Version @relation(fields: [versionId], references: [versionId], onDelete: Cascade, onUpdate: Cascade)

    launches LaunchOption[]

    gameDependees GameVersion[]
    dlcDependees  DLCVersion[]

    platformId String
    platform   PlatformLink @relation(fields: [platformId], references: [id])
}

// Platform specific object
model ModVersion {
    versionId String  @id
    version   Version @relation(fields: [versionId], references: [versionId], onDelete: Cascade, onUpdate: Cascade)

    dependencies String[]

    platformId String
    platform   PlatformLink @relation(fields: [platformId], references: [id])
}

// A save slot for a game
model SaveSlot {
    gameId String
    game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    index  Int

    createdAt DateTime @default(now())
    playtime  Float    @default(0) // hours

    lastUsedClientId String?
    lastUsedClient   Client? @relation(fields: [lastUsedClientId], references: [id])

    historyObjectIds String[] // list of objects
    historyChecksums String[] // list of hashes

    @@id([gameId, userId, index], name: "id")
}

model Screenshot {
    id String @id @default(uuid())

    gameId String
    game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    objectId String
    private  Boolean // if other users can see

    createdAt DateTime @default(now()) @db.Timestamptz(0)

    @@index([gameId, userId])
    @@index([userId])
}

model Playtime {
    gameId String
    game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    seconds Int // seconds user has spent playing the game

    updatedAt DateTime @updatedAt @db.Timestamptz(6)
    createdAt DateTime @default(now()) @db.Timestamptz(6)

    @@id([gameId, userId])
    @@index([userId])
}

model ObjectHash {
    id   String @id
    hash String
}
